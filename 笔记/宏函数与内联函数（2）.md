# 宏函数与内联函数（2）：为什么 CUDA_CHECK 必须用宏？

## 问题引入

内联函数不是也会"把代码复制到每个调用点"吗？那为什么不能用内联函数实现 CUDA_CHECK？

```cpp
// cuda_utils.h 文件
inline void cudaCheck(cudaError_t err) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                __FILE__, __LINE__, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}

// main.cu 文件
void foo() {
    float* d_data;
    cudaCheck(cudaMalloc(&d_data, 1024));  // 第23行
    cudaCheck(cudaMemcpy(...));             // 第24行
}
```

按理说，内联函数会把 `cudaCheck` 的代码复制到第23行和第24行，那为什么不能正确获取调用点的位置？

---

## 关键：编译流程的顺序

```
源代码 → 预处理器 → 编译器 → 汇编器 → 链接器
           ↑            ↑
       __FILE__      inline
       __LINE__      在这里展开
       在这里替换
```

**`__FILE__` 和 `__LINE__` 是预处理器宏**，它们在预处理阶段就被替换了。而内联是**编译阶段**才发生的事情。

---

## 详细流程分析

### 第1步：预处理器处理 cuda_utils.h

原始代码：
```cpp
// cuda_utils.h 第5行
inline void cudaCheck(cudaError_t err) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                __FILE__, __LINE__, cudaGetErrorString(err));
    }
}
```

**预处理器**看到 `__FILE__` 和 `__LINE__`，立刻替换为**当前位置**：

```cpp
// 预处理后的代码（编译器看到的）
inline void cudaCheck(cudaError_t err) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                "cuda_utils.h", 5, cudaGetErrorString(err));
                // ↑ 已经是固定的字符串和数字了！
    }
}
```

> [!IMPORTANT]
> 预处理完成后，`__FILE__` 和 `__LINE__` 已经不存在了，它们变成了固定的值 `"cuda_utils.h"` 和 `5`。

### 第2步：编译器处理内联

**编译器**看到的代码中，`"cuda_utils.h"` 和 `5` 已经是**固定的值**了！

当编译器把函数内联到 main.cu 的第23行时：

```cpp
// main.cu
void foo() {
    float* d_data;
    
    // cudaCheck(cudaMalloc(&d_data, 1024)); 内联展开为：
    {
        cudaError_t err = cudaMalloc(&d_data, 1024);
        if (err != cudaSuccess) {
            fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                    "cuda_utils.h", 5, cudaGetErrorString(err));
                    // ↑ 复制过来的还是这个固定值！
        }
    }
}
```

**代码确实被复制到了每个调用点，但复制的是预处理后的代码，`"cuda_utils.h"` 和 `5` 已经被"烧死"在里面了！**

---

## 时间线对比

### 宏的处理流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 预处理器看到 CUDA_CHECK(cudaMalloc...) 在 main.cu:23    │
│ 2. 预处理器在第23行展开宏                                   │
│ 3. __FILE__ = "main.cu", __LINE__ = 23  ← 调用点！         │
│ 4. 编译器编译已展开的代码                                   │
└─────────────────────────────────────────────────────────────┘
```

宏展开时，`__FILE__` 和 `__LINE__` 获取的是**宏调用处**的位置。

### 内联函数的处理流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 预处理器看到 cudaCheck 函数定义在 cuda_utils.h:5        │
│ 2. 预处理器在第5行替换 __FILE__ 和 __LINE__                │
│ 3. __FILE__ = "cuda_utils.h", __LINE__ = 5  ← 函数定义处！ │
│ 4. 编译器看到函数（值已固定）                               │
│ 5. 编译器把函数内联到 main.cu:23                           │
│ 6. 但复制的代码里还是 "cuda_utils.h" 和 5                  │
└─────────────────────────────────────────────────────────────┘
```

等编译器进行内联时，`__FILE__` 和 `__LINE__` 早就被替换成固定值了。

---

## 形象比喻

想象一张名片：

**宏 = 在每个地方现场手写名片**
```
在 main.cu:23 → 写"main.cu:23"
在 main.cu:24 → 写"main.cu:24"
```

**内联函数 = 复印预先印好的名片**
```
原版名片上印着"cuda_utils.h:5"
复印100份 → 每份都是"cuda_utils.h:5"
```

---

## 结论

> **`__FILE__` 和 `__LINE__` 在预处理阶段就被替换了，而内联是在编译阶段才发生的。等编译器"复制"函数体时，这些值早就被"烧死"成固定的字符串了。**

这就是为什么 CUDA_CHECK **必须用宏**：
- 宏在**预处理阶段**展开
- `__FILE__` 和 `__LINE__` 获取的是**宏调用点**的位置
- 而不是宏定义的位置

---

## 附：如果非要用函数怎么办？

### 方法1：手动传递 `__LINE__`（不推荐）

可以在调用时显式传递 `__FILE__` 和 `__LINE__`：

```cpp
// 定义函数（普通或内联都行）
void cudaCheck(cudaError_t err, const char* file, int line) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                file, line, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}

// 使用时必须手动传递
void foo() {
    float* d_data;
    cudaCheck(cudaMalloc(&d_data, 1024), __FILE__, __LINE__);  // ✅ 可以定位到第23行
}
```

**为什么可以？**

因为 `__LINE__` 是在**调用点**被替换的：

```cpp
// 源代码（第23行）
cudaCheck(cudaMalloc(&d_data, 1024), __FILE__, __LINE__);

// 预处理后（第23行）
cudaCheck(cudaMalloc(&d_data, 1024), "main.cu", 23);
```

**缺点：**
- ❌ 使用繁琐，每次都要写 `__FILE__, __LINE__`
- ❌ 容易忘记或写错
- ❌ 代码冗长

### 方法2：宏+函数结合（推荐）

这是最佳实践：

```cpp
// 实际的错误处理函数
inline void cudaCheckImpl(cudaError_t err, const char* file, int line) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                file, line, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}

// 宏负责捕获 __FILE__ 和 __LINE__，然后传给函数
#define CUDA_CHECK(call) cudaCheckImpl(call, __FILE__, __LINE__)

// 使用简洁
CUDA_CHECK(cudaMalloc(&d_data, 1024));  // ✅ 简洁又准确
```

**优点：**
- ✅ 使用简洁（像纯宏一样）
- ✅ 类型安全（函数提供类型检查）
- ✅ 易于调试（可以在函数中设置断点）
- ✅ 自动捕获调用点位置（宏负责传递）

---

## 三种方案对比

| 方式 | 可行性 | 使用示例 | 优点 | 缺点 |
|------|--------|----------|------|------|
| **纯宏** | ✅ | `CUDA_CHECK(call)` | 简洁、自动捕获位置 | 无类型检查、难调试 |
| **纯函数 + 手动传** | ✅ | `check(call, __FILE__, __LINE__)` | 类型安全 | 繁琐、容易忘记 |
| **宏+函数结合** | ✅ | `CUDA_CHECK(call)` | **简洁、安全、易调试** | 需要两个定义 |

> [!TIP]
> **推荐使用宏+函数结合的方式**，这是工业界的最佳实践，既有宏的便利性，又有函数的类型安全和可调试性。

# 宏函数与内联函数（2）：为什么 CUDA_CHECK 必须用宏？

## 问题引入

内联函数不是也会"把代码复制到每个调用点"吗？那为什么不能用内联函数实现 CUDA_CHECK？

```cpp
// cuda_utils.h 文件
inline void cudaCheck(cudaError_t err) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                __FILE__, __LINE__, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}

// main.cu 文件
void foo() {
    float* d_data;
    cudaCheck(cudaMalloc(&d_data, 1024));  // 第23行
    cudaCheck(cudaMemcpy(...));             // 第24行
}
```

按理说，内联函数会把 `cudaCheck` 的代码复制到第23行和第24行，那为什么不能正确获取调用点的位置？

---

## 关键：编译流程的顺序

```
源代码 → 预处理器 → 编译器 → 汇编器 → 链接器
           ↑            ↑
       __FILE__      inline
       __LINE__      在这里展开
       在这里替换
```

**`__FILE__` 和 `__LINE__` 是预处理器宏**，它们在预处理阶段就被替换了。而内联是**编译阶段**才发生的事情。

---

## 详细流程分析

### 第1步：预处理器处理 cuda_utils.h

原始代码：
```cpp
// cuda_utils.h 第5行
inline void cudaCheck(cudaError_t err) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                __FILE__, __LINE__, cudaGetErrorString(err));
    }
}
```

**预处理器**看到 `__FILE__` 和 `__LINE__`，立刻替换为**当前位置**：

```cpp
// 预处理后的代码（编译器看到的）
inline void cudaCheck(cudaError_t err) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                "cuda_utils.h", 5, cudaGetErrorString(err));
                // ↑ 已经是固定的字符串和数字了！
    }
}
```

> [!IMPORTANT]
> 预处理完成后，`__FILE__` 和 `__LINE__` 已经不存在了，它们变成了固定的值 `"cuda_utils.h"` 和 `5`。

### 第2步：编译器处理内联

**编译器**看到的代码中，`"cuda_utils.h"` 和 `5` 已经是**固定的值**了！

当编译器把函数内联到 main.cu 的第23行时：

```cpp
// main.cu
void foo() {
    float* d_data;
    
    // cudaCheck(cudaMalloc(&d_data, 1024)); 内联展开为：
    {
        cudaError_t err = cudaMalloc(&d_data, 1024);
        if (err != cudaSuccess) {
            fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                    "cuda_utils.h", 5, cudaGetErrorString(err));
                    // ↑ 复制过来的还是这个固定值！
        }
    }
}
```

**代码确实被复制到了每个调用点，但复制的是预处理后的代码，`"cuda_utils.h"` 和 `5` 已经被"烧死"在里面了！**

---

## 时间线对比

### 宏的处理流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 预处理器看到 CUDA_CHECK(cudaMalloc...) 在 main.cu:23    │
│ 2. 预处理器在第23行展开宏                                   │
│ 3. __FILE__ = "main.cu", __LINE__ = 23  ← 调用点！         │
│ 4. 编译器编译已展开的代码                                   │
└─────────────────────────────────────────────────────────────┘
```

宏展开时，`__FILE__` 和 `__LINE__` 获取的是**宏调用处**的位置。

### 内联函数的处理流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 预处理器看到 cudaCheck 函数定义在 cuda_utils.h:5        │
│ 2. 预处理器在第5行替换 __FILE__ 和 __LINE__                │
│ 3. __FILE__ = "cuda_utils.h", __LINE__ = 5  ← 函数定义处！ │
│ 4. 编译器看到函数（值已固定）                               │
│ 5. 编译器把函数内联到 main.cu:23                           │
│ 6. 但复制的代码里还是 "cuda_utils.h" 和 5                  │
└─────────────────────────────────────────────────────────────┘
```

等编译器进行内联时，`__FILE__` 和 `__LINE__` 早就被替换成固定值了。

---

## 形象比喻

想象一张名片：

**宏 = 在每个地方现场手写名片**
```
在 main.cu:23 → 写"main.cu:23"
在 main.cu:24 → 写"main.cu:24"
```

**内联函数 = 复印预先印好的名片**
```
原版名片上印着"cuda_utils.h:5"
复印100份 → 每份都是"cuda_utils.h:5"
```

---

## 结论

> **`__FILE__` 和 `__LINE__` 在预处理阶段就被替换了，而内联是在编译阶段才发生的。等编译器"复制"函数体时，这些值早就被"烧死"成固定的字符串了。**

这就是为什么 CUDA_CHECK **必须用宏**：
- 宏在**预处理阶段**展开
- `__FILE__` 和 `__LINE__` 获取的是**宏调用点**的位置
- 而不是宏定义的位置

---

## 附：如果非要用函数怎么办？

可以用宏+函数配合：

```cpp
// 实际的错误处理函数
inline void cudaCheckImpl(cudaError_t err, const char* file, int line) {
    if (err != cudaSuccess) {
        fprintf(stderr, "CUDA Error at %s:%d: %s\n",
                file, line, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}

// 宏负责捕获 __FILE__ 和 __LINE__，然后传给函数
#define CUDA_CHECK(call) cudaCheckImpl(call, __FILE__, __LINE__)
```

这样既有函数的类型安全，又能正确获取调用点位置。

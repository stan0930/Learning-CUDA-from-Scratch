# 静态库 vs 动态库深度解析

## 一、静态库 (Static Library, `.lib` / `.a`)

**关键词**：复制、硬编码、私有

### 1. 物理形态 📦

静态库本质上就是一个**归档包 (Archive)**。它里面把一堆编译好的 `.obj`（目标文件）像用拉链打包一样压在一起。

### 2. 链接过程（编译时）

当你编译程序时，**链接器 (Linker)** 的工作流程是这样的：

1. **扫描**：发现你的代码调用了 `add()`
2. **查找**：去静态库里找，发现 `math.lib` 里有一个 `add.obj` 包含这个函数
3. **暴力拆包**：链接器把 `add.obj` 的二进制指令（机器码）直接提取出来
4. **复制粘贴**：把这堆指令直接塞进你的 `.exe` 文件的代码段（`.text` section）里
5. **地址重定位 (Relocation)**：链接器计算好 `add()` 函数在 `.exe` 里的确切偏移量，把你调用它的地方直接改成 `CALL 0x00401000`（假设这是计算后的绝对地址）

### 3. 内存视角（运行时）

#### 代码冗余
- 如果有 **10 个程序**都用了 `math.lib`，内存里就会有 **10 份** `add()` 函数的机器码副本
- 大家各用各的，互不干扰

#### 执行快 ⚡
- CPU 执行到 `CALL` 指令时，直接跳到同一个程序空间内的地址
- 没有任何中间商赚差价，**速度最快**

---

## 二、动态库 (Dynamic Library, `.dll` / `.so`)

**关键词**：映射、间接寻址、共享

### 1. 物理形态 🧩

动态库本身是一个**完整的、可执行的模块**。它有自己的代码段、数据段，只是没有 `main` 函数入口，不能单独跑。

### 2. 链接过程（编译时）

链接器在处理动态库时，极其"敷衍"：

1. **发现**：你调用了 `add()`
2. **确认**：去导入库（Import Library，那个 `.lib`）里看一眼，确认 `add()` 确实在 `math.dll` 里
3. **不复制机器码**：链接器绝对不会把 `add()` 的代码抄过来
4. **留个桩 (Stub)**：链接器在你的 `.exe` 里生成一段很小的代码（桩代码），并在**导入表 (Import Table)** 里记下一笔：
   > "运行的时候，请去加载 `math.dll`，并找到 `add` 函数的地址填到这里。"

### 3. 内存视角（运行时 —— 最精彩的部分）✨

当你双击运行程序时，**操作系统加载器 (OS Loader)** 登场：

#### 加载 DLL
加载器发现你需要 `math.dll`，就会把 `math.dll` 的代码段**映射到物理内存**中。

#### 共享物理内存（关键！）🔑
- 如果此时有 **100 个程序**都在运行且都用了 `math.dll`
- 操作系统只需要在物理内存里加载 **1 份** `math.dll` 的代码
- 然后利用**虚拟内存 (Virtual Memory)** 技术，把这同一份物理内存，映射到这 100 个进程各自的虚拟地址空间里
- **省内存神器！**

### 4. 函数调用是如何实现的？（PLT/IAT 机制）

这就涉及到底层汇编了。既然代码不在你的 `.exe` 里，CPU 怎么跳过去？这里用到了**"间接寻址"**。

#### 静态库的汇编：
```asm
CALL 0x401000  ; 直接跳到目标地址，地址是写死的
```

#### 动态库的汇编：
你的代码里调用的其实不是真正的函数，而是一个**跳转表**（Windows 下叫 **IAT - 导入地址表**，Linux 下叫 **PLT/GOT**）。

```asm
; 你的代码：
CALL [0x00502000]  ; 嘿，CPU，去 502000 这个地址看看，里面存了真正的函数地址是多少
```

**IAT 表** (位于 `0x00502000`)：
- 在程序刚启动时，操作系统会算出 DLL 被加载到了哪里
- 把真正的函数地址填写在这个格子里

**跳转**：
- CPU 读到真正的地址，然后跳进 DLL 的内存区域执行

---

## 三、底层对比总结

| 维度 | 静态库 (`.lib`) | 动态库 (`.dll` / `.so`) |
|:---|:---|:---|
| **存在形式** | `.obj` 的集合 (压缩包) | 完整的可执行模块 |
| **链接时机** | 编译时 (Compile Time) | 运行时 (Load Time) |
| **代码位置** | 在你的 `.exe` 肚子里 | 在系统内存的某个角落 |
| **CPU 指令** | `CALL` 直接地址 (直达) | `CALL [查找表]` (通过指针间接跳转) |
| **物理内存** | 10 个程序 = 10 份代码 (浪费) | 10 个程序 = 1 份代码 (极其省内存) |
| **更新库** | 更新了，你要重新编译整个程序 | 换个 DLL 文件就行 (因为查找表会自动更新地址) |

---

## 💡 关键要点

### 静态库 ✅
- ✅ **速度快**：无间接寻址，直接跳转
- ✅ **部署简单**：一个 `.exe` 搞定，不用担心缺 DLL
- ❌ **内存浪费**：每个程序都有一份副本
- ❌ **更新麻烦**：必须重新编译

### 动态库 ✅
- ✅ **省内存**：多个程序共享一份代码
- ✅ **易更新**：只需替换 DLL 文件
- ❌ **速度稍慢**：多一次间接寻址
- ❌ **依赖地狱**：缺 DLL 就无法运行（DLL Hell）
